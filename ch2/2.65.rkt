#lang sicp

(define entry car)

(define left-branch cadr)

(define right-branch caddr)

(define (make-tree entry left right)
  (list entry left right))

(define (element-of-set? x set)
  (letrec ((e (lambda (set)
                (cond ((null? set) #f)
                      ((< x (entry set)) (e (left-branch set)))
                      ((> x (entry set)) (e (right-branch set)))
                      (else #t)))))
    (e set)))

(define (adjoin-set x set)
  (letrec ((a (lambda (set)
                (cond ((null? set)
                       (make-tree x '() '()))
                      ((< x (entry set))
                       (make-tree (entry set)
                                  (a (left-branch set))
                                  (right-branch set)))
                      ((> x (entry set))
                       (make-tree (entry set)
                                  (left-branch set)
                                  (a (right-branch set))))
                      (else set)))))
    (a set)))

(define (make-set . args)
  (letrec ((m (lambda (args result)
                (if (null? args)
                    result
                    (m (cdr args) (adjoin-set (car args) result))))))
    (m args '())))

(define (tree->list t)
  (letrec ((tl (lambda (t result)
                 (if (null? t)
                     result
                     (tl (left-branch t)
                         (cons (entry t)
                               (tl (right-branch t)
                                   result)))))))
    (tl t '())))

(define (list->tree l)
  (letrec ((lt (lambda (l n)
                 (if (zero? n)
                     (cons '() l)
                     (let* ((left-size (quotient (dec n) 2))
                            (left-result (lt l left-size))
                            (left-tree (car left-result))
                            (non-left-l (cdr left-result))
                            (right-size (- n (inc left-size)))
                            (this-entry (car non-left-l))
                            (right-result (lt (cdr non-left-l) right-size))
                            (right-tree (car right-result))
                            (remaining-l (cdr right-result)))
                       (cons (make-tree this-entry left-tree right-tree)
                             remaining-l))))))
    (car (lt l (length l)))))

(define (intersection-set set1 set2)
  (letrec ((i (lambda (ls1 result)
                (cond ((null? ls1)
                       (list->tree result))
                      ((element-of-set? (car ls1) set2)
                       (i (cdr ls1)
                          (append result (list (car ls1)))))
                      (else (i (cdr ls1) result))))))
    (i (tree->list set1) '())))

(define (union-set set1 set2)
  (letrec ((u (lambda (ls1 result)
                (cond ((null? ls1)
                       (list->tree (append result
                                           (tree->list set2))))
                      ((element-of-set? (car ls1) set2)
                       (u (cdr ls1) result))
                      (else (u (cdr ls1)
                               (append result (list (car ls1)))))))))
    (u (tree->list set1) '())))

(define (displayln x)
  (display x)
  (newline))

(let ((set1 (make-set 1 2 3 4 5))
      (set2 (make-set 3 4 5 6 7)))
  (displayln (intersection-set set1 set2))
  (displayln (union-set set1 set2)))
;; (4 (3 () ()) (5 () ()))
;; (4 (2 (1 () ()) (3 () ())) (6 (5 () ()) (7 () ())))