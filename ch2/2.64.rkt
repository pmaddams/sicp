#lang sicp

(define entry car)

(define left-branch cadr)

(define right-branch caddr)

(define (make-tree entry left right)
  (list entry left right))

(define (element-of-set? x set)
  (letrec ((e (lambda (set)
                (cond ((null? set) #f)
                      ((< x (entry set)) (e (left-branch set)))
                      ((> x (entry set)) (e (right-branch set)))
                      (else #t)))))
    (e set)))

(define (adjoin-set x set)
  (letrec ((a (lambda (set)
                (cond ((null? set)
                       (make-tree x '() '()))
                      ((< x (entry set))
                       (make-tree (entry set)
                                  (a (left-branch set))
                                  (right-branch set)))
                      ((> x (entry set))
                       (make-tree (entry set)
                                  (left-branch set)
                                  (a (right-branch set))))
                      (else set)))))
    (a set)))

(define (make-set . args)
  (letrec ((m (lambda (args result)
                (if (null? args)
                    result
                    (m (cdr args) (adjoin-set (car args) result))))))
    (m args '())))

(define (tree->list t)
  (letrec ((tl (lambda (t result)
                 (if (null? t)
                     result
                     (tl (left-branch t)
                         (cons (entry t)
                               (tl (right-branch t)
                                   result)))))))
    (tl t '())))

(define (list->tree l)
  (letrec ((lt (lambda (l n)
                 (if (zero? n)
                     (cons '() l)
                     (let* ((left-size (quotient (dec n) 2))
                            (left-result (lt l left-size))
                            (left-tree (car left-result))
                            (non-left-l (cdr left-result))
                            (right-size (- n (inc left-size)))
                            (this-entry (car non-left-l))
                            (right-result (lt (cdr non-left-l) right-size))
                            (right-tree (car right-result))
                            (remaining-l (cdr right-result)))
                       (cons (make-tree this-entry left-tree right-tree)
                             remaining-l))))))
    (lt l (length l))))

(define (displayln x)
  (display x)
  (newline))

(let* ((t1 (make-set 1 3 5 7 9 11))
       (l (tree->list t1))
       (t2 (list->tree l)))
  (displayln t1)
  (displayln l)
  (displayln t2))
;; (1 () (3 () (5 () (7 () (9 () (11 () ()))))))
;; (1 3 5 7 9 11)
;; ((5 (1 () (3 () ())) (9 (7 () ()) (11 () ()))))