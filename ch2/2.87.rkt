#lang sicp

(#%require (only racket/base
                 make-hash
                 hash-has-key?
                 hash-ref
                 hash-set!))

(define (make-table)
  (let* ((table (make-hash))
         (get (lambda (k1 k2)
                (hash-ref table
                          (list k1 k2)
                          #f)))
         (put (lambda (k1 k2 v)
                (hash-set! table
                           (list k1 k2)
                           v)))
         (dispatch (lambda (m)
                     (case m
                       ('get get)
                       ('put put)
                       (else (error "table: unknown method:" m))))))
    dispatch))

(define table (make-table))

(define get (table 'get))

(define put (table 'put))

(define attach-tag cons)

(define (type-tag datum)
  (if (pair? datum)
      (car datum)
      (error "type-tag: bad tagged datum:" datum)))

(define (contents datum)
  (if (pair? datum)
      (cdr datum)
      (error "contents: bad tagged datum:" datum)))

(define (displayln x)
  (display x)
  (newline))

(define (install-polynomial-package)
  (letrec ((make-poly cons)
           (variable car)
           (term-list cdr)
           (variable? symbol?)
           (same-variable? (lambda (v1 v2)
                             (and (variable? v1)
                                  (variable? v2)
                                  (eq? v1 v2))))
           (order car)
           (coeff cadr)
           (adjoin-term (lambda (t l)
                          (if (=zero? (coeff t))
                              t
                              (cons t l))))
           (the-empty-termlist '())
           (first-term car)
           (rest-terms cdr)
           (empty-termlist? null?)
           (make-term (lambda (order coeff)
                        (list order coeff)))
           (add-terms (lambda (l1 l2)
                        (cond ((empty-termlist? l1) l2)
                              ((empty-termlist? l2) l1)
                              (else (let ((t1 (first-term l1))
                                          (t2 (first-term l2)))
                                      (cond ((> (order t1)
                                                (order t2))
                                             (adjoin-term t1
                                                          (add-terms (rest-terms l1) l2)))
                                            ((< (order t1)
                                                (order t2))
                                             (adjoin-term t2
                                                          (add-terms l1 (rest-terms l2))))
                                            (else
                                             (adjoin-term (make-term (order t1)
                                                                     (add (coeff t1)
                                                                          (coeff t2)))
                                                          (make-term (rest-terms l1)
                                                                     (rest-terms l2))))))))))
           (mul-term-by-all-terms (lambda (t1 l)
                                    (if (empty-termlist? l)
                                        (the-empty-termlist)
                                        (let ((t2 (first-term l)))
                                          (adjoin-term (make-term (+ (order t1)
                                                                     (order t2))
                                                                  (mul (coeff t1)
                                                                       (coeff t2)))
                                                       (mul-term-by-all-terms t1
                                                                              (rest-terms l)))))))
           (mul-terms (lambda (l1 l2)
                        (if (empty-termlist l1)
                            (the-empty-termlist)
                            (add-terms (mul-terms-by-all-terms (first-term l1)
                                                               l2)
                                       (mul-terms (rest-terms l1)
                                                  l2)))))
           (add-poly (lambda (p1 p2)
                       (if (same-variable? (variable p1)
                                           (variable p2))
                           (make-poly (variable p1)
                                      (add-terms (term-list p1)
                                                 (term-list p2)))
                           (error "add-poly: polys not in same var:" (list p1 p2)))))
           (mul-poly (lambda (p1 p2)
                       (if (same-variable? (variable p1)
                                           (variable p2))
                           (make-poly (variable p1)
                                      (mul-terms (term-list p1)
                                                 (term-list p2)))
                           (error "mul-poly: polys not in same var:" (list p1 p2)))))
           (tag (lambda (p)
                  (attach-tag 'polynomial p))))
    (display "install-polynomial-package...")
    (put 'add '(polynomial polynomial)
         (lambda (p1 p2)
           (tag (add-poly p1 p2))))
    (put 'mul '(polynomial polynomial)
         (lambda (p1 p2)
           (tag (mul-poly p1 p2))))
    (put 'make 'polynomial
         (lambda (var terms)
           (tag (make-poly var terms))))
    (displayln "done.")))
