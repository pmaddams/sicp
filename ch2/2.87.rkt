#lang sicp

(define (make-table same-key?)
  (let* ((table (list '<table>))
         (assoc (lambda (key records)
                  (letrec ((a (lambda (records)
                                (cond ((null? records) #f)
                                      ((same-key? key (caar records)) (car records))
                                      (else (a (cdr records)))))))
                    (a records))))
         (lookup (lambda (key1 key2)
                   (let ((subtable (assoc key1 (cdr table))))
                     (if subtable
                         (let ((record (assoc key2 (cdr subtable))))
                           (if record
                               (cdr record)
                               #f))
                         #f))))
         (insert! (lambda (key1 key2 value)
                    (let ((subtable (assoc key1 (cdr table))))
                      (if subtable
                          (let ((record (assoc key2 (cdr subtable))))
                            (if record
                                (set-cdr! record value)
                                (set-cdr! subtable
                                          (cons (cons key2 value)
                                                (cdr subtable)))))
                          (set-cdr! table
                                    (cons (list key1
                                                (cons key2 value))
                                          (cdr table)))))))
         (dispatch (lambda (m)
                     (cond ((eq? m 'lookup) lookup)
                           ((eq? m 'insert!) insert!)
                           (else (error "make-table: undefined operation:" m))))))
    dispatch))

(define table (make-table equal?))

(define get (table 'lookup))

(define put (table 'insert!))

(define attach-tag cons)

(define (type-tag datum)
  (if (pair? datum)
      (car datum)
      (error "type-tag: bad tagged datum:" datum)))

(define (contents datum)
  (if (pair? datum)
      (cdr datum)
      (error "contents: bad tagged datum:" datum)))

(define (displayln x)
  (display x)
  (newline))

(define (install-polynomial-package)
  (letrec ((make-poly cons)
           (variable car)
           (term-list cdr)
           (variable? symbol?)
           (same-variable? (lambda (v1 v2)
                             (and (variable? v1)
                                  (variable? v2)
                                  (eq? v1 v2))))
           (order car)
           (coeff cadr)
           (adjoin-term (lambda (t l)
                          (if (=zero? (coeff t))
                              t
                              (cons t l))))
           (the-empty-termlist '())
           (first-term car)
           (rest-terms cdr)
           (empty-termlist? null?)
           (make-term (lambda (order coeff)
                        (list order coeff)))
           (add-terms (lambda (l1 l2)
                        (cond ((empty-termlist? l1) l2)
                              ((empty-termlist? l2) l1)
                              (else (let ((t1 (first-term l1))
                                          (t2 (first-term l2)))
                                      (cond ((> (order t1)
                                                (order t2))
                                             (adjoin-term t1
                                                          (add-terms (rest-terms l1) l2)))
                                            ((< (order t1)
                                                (order t2))
                                             (adjoin-term t2
                                                          (add-terms l1 (rest-terms l2))))
                                            (else
                                             (adjoin-term (make-term (order t1)
                                                                     (add (coeff t1)
                                                                          (coeff t2)))
                                                          (make-term (rest-terms l1)
                                                                     (rest-terms l2))))))))))
           (mul-term-by-all-terms (lambda (t1 l)
                                    (if (empty-termlist? l)
                                        (the-empty-termlist)
                                        (let ((t2 (first-term l)))
                                          (adjoin-term (make-term (+ (order t1)
                                                                     (order t2))
                                                                  (mul (coeff t1)
                                                                       (coeff t2)))
                                                       (mul-term-by-all-terms t1
                                                                              (rest-terms l)))))))
           (mul-terms (lambda (l1 l2)
                        (if (empty-termlist l1)
                            (the-empty-termlist)
                            (add-terms (mul-terms-by-all-terms (first-term l1)
                                                               l2)
                                       (mul-terms (rest-terms l1)
                                                  l2)))))
           (add-poly (lambda (p1 p2)
                       (if (same-variable? (variable p1)
                                           (variable p2))
                           (make-poly (variable p1)
                                      (add-terms (term-list p1)
                                                 (term-list p2)))
                           (error "add-poly: polys not in same var:" (list p1 p2)))))
           (mul-poly (lambda (p1 p2)
                       (if (same-variable? (variable p1)
                                           (variable p2))
                           (make-poly (variable p1)
                                      (mul-terms (term-list p1)
                                                 (term-list p2)))
                           (error "mul-poly: polys not in same var:" (list p1 p2)))))
           (tag (lambda (p)
                  (attach-tag 'polynomial p))))
    (display "install-polynomial-package...")
    (put 'add '(polynomial polynomial)
         (lambda (p1 p2)
           (tag (add-poly p1 p2))))
    (put 'mul '(polynomial polynomial)
         (lambda (p1 p2)
           (tag (mul-poly p1 p2))))
    (put 'make 'polynomial
         (lambda (var terms)
           (tag (make-poly var terms))))
    (displayln "done.")))
