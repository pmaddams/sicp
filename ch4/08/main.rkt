#lang racket/base

; Exercise 4.8: Metacircular evaluator

(struct primitive (impl))

(define primitives
  `((cons . ,cons)
    (car . ,car)
    (cdr . ,cdr)
    (pair? . ,pair?)
    (null? . ,null?)
    (+ . ,+)
    (- . ,-)
    (* . ,*)
    (/ . ,/)
    (< . ,<)
    (> . ,>)
    (= . ,=)
    (eq? . ,eq?)
    (display . ,display)
    (newline . ,newline)))

(struct closure (vars body env))

(define (meval expr env)
  (cond ((or (number? expr) (string? expr)) expr)
        ((symbol? expr) (get-var expr env))
        (else (case (car expr)
                ('quote (cadr expr))
                ('lambda (let ((vars (cadr expr))
                               (body (cddr expr)))
                           (closure vars body env)))
                ('define (eval-define expr env))
                ('set! (eval-set expr env))
                ('if (eval-if expr env))
                ('begin (eval-begin (cdr expr) env))
                ('cond (eval-if (cond->if expr) env))
                (else (mapply (meval (car expr) env)
                              (eval-list (cdr expr) env)))))))

(define (mapply proc vals)
  (if (primitive? proc)
      (apply (primitive-impl proc) vals)
      (eval-begin (closure-body proc)
                  (extend (closure-vars proc)
                          vals
                          (closure-env proc)))))

(define (eval-define expr env)
  (let ((var (if (symbol? (cadr expr))
                 (cadr expr)
                 (caadr expr)))
        (val (if (symbol? (cadr expr))
                 (caddr expr)
                 (let ((vars (cdadr expr))
                       (body (cddr expr)))
                   (cons 'lambda (cons vars body))))))
    (def-var var (meval val env) env)))

(define (eval-set expr env)
  (let ((var (cadr expr))
        (val (caddr expr)))
    (set-var var (meval val env) env)))

(define (eval-begin exprs env)
  (if (last? exprs)
      (meval (car exprs) env)
      (begin (meval (car exprs) env)
             (eval-begin (cdr exprs) env))))

(define (last? l)
  (null? (cdr l)))

(define (eval-if expr env)
  (let ((predicate (cadr expr))
        (consequent (caddr expr))
        (alternative (cadddr expr)))
    (if (true? (meval predicate env))
        (meval consequent env)
        (meval alternative env))))

(define (true? x)
  (not (false? x)))

(define (false? x)
  (eq? x #f))

(define (cond->if expr) (expand (cdr expr)))

(define (expand clauses)
  (if (null? clauses)
      'false
      (let* ((first (car clauses))
             (predicate (car first))
             (actions (cdr first))
             (rest (cdr clauses)))
        (if (eq? predicate 'else)
            (if (null? rest)
                (seq->expr actions)
                (error "else clause must be last"))
            (list 'if predicate (seq->expr actions) (expand rest))))))

(define (seq->expr seq)
  (cond ((null? seq) '())
        ((last? seq) (car seq))
        (else (cons 'begin seq))))

(define (eval-list exprs env)
  (if (null? exprs)
      '()
      (cons (meval (car exprs) env)
            (eval-list (cdr exprs) env))))

(define (extend vars vals env)
  (cons (make-frame vars vals) env))

(define (make-frame vars vals)
  (if (not (= (length vars) (length vals)))
      (error "arity mismatch:" vars vals)
      (let ((assocs (map cons vars vals)))
        (make-hash assocs))))

(define (def-var var val env)
  (let ((frame (car env)))
    (hash-set! frame var val)))

(define (get-var var env)
  (if (null? env)
      (error "undefined:" var)
      (let ((frame (car env)))
        (if (hash-has-key? frame var)
            (hash-ref frame var)
            (get-var var (cdr env))))))

(define (set-var var val env)
  (if (null? env)
      (error "undefined:" var)
      (let ((frame (car env)))
        (if (hash-has-key? frame var)
            (hash-set! frame var val)
            (set-var var val (cdr env))))))

(define (make-env)
  (let* ((vars (map car primitives))
         (vals (map primitive (map cdr primitives)))
         (env (extend vars vals '())))
    (def-var 'true #t env)
    (def-var 'false #f env)
    env))

(define (interpret code)
  (let ((env (make-env)))
    (for ((expr code))
      (let ((val (meval expr env)))
        (unless (void? val)
          (displayln val))))))
