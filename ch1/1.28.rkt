#lang sicp

(define (expmod-with-composite-test base exp m)
  (letrec ((square (lambda (x)
                     (expt x 2)))
           (e (lambda (exp)
                (cond ((zero? exp) 1)
                      ((even? exp) (let* ((x (e (/ exp 2)))
                                          (y (remainder (square x) m)))
                                     (if (and (= y 1)
                                              (not (= x 1))
                                              (not (= x (dec m))))
                                         0
                                         y)))
                      (else (remainder (* base (e (dec exp)))
                                       m))))))
    (e exp)))

(define (prime? n)
  (letrec ((miller-rabin (lambda (n)
                           (let ((a (inc (random (dec n)))))
                             (= 1 (expmod-with-composite-test a (dec n) n)))))
           (p (lambda (times)
                (cond ((zero? times) #t)
                      ((miller-rabin n) (p (dec times)))
                      (else #f)))))
    (cond ((<= n 1) #f)
          ((= n 2) #t)
          ((even? n) #f)
          (else (p 10)))))