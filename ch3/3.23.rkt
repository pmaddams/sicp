#lang sicp

(define front-ptr car)

(define rear-ptr cdr)

(define set-front-ptr! set-car!)

(define set-rear-ptr! set-cdr!)

(define prev-ptr cadr)

(define next-ptr cddr)

(define (set-prev-ptr! item prev)
  (set-car! (cdr item) prev))

(define (set-next-ptr! item next)
  (set-cdr! (cdr item) next))

(define (empty-deque? dq)
  (null? (front-ptr dq)))

(define (make-deque)
  (cons '() '()))

(define (front-deque dq)
  (if (empty-deque? dq)
      (error "front-deque: empty deque:" dq)
      (car (front-ptr dq))))

(define (rear-deque dq)
  (if (empty-deque? dq)
      (error "rear-deque: empty deque:" dq)
      (car (rear-ptr dq))))

(define (insert-deque! dq item)
  (let* ((elem (cons item (cons '() '())))
         (empty (lambda ()
                  (set-front-ptr! dq elem)
                  (set-rear-ptr! dq elem)
                  dq))
         (front (lambda ()
                  (set-next-ptr! elem (front-ptr dq))
                  (set-prev-ptr! (front-ptr dq) elem)
                  (set-front-ptr! dq elem)
                  dq))
         (rear (lambda ()
                 (set-prev-ptr! elem (rear-ptr dq))
                 (set-next-ptr! (rear-ptr dq) elem)
                 (set-rear-ptr! dq elem)
                 dq))
         (dispatch (lambda (m)
                     (cond ((and (empty-deque? dq)
                                 (or (eq? m 'front)
                                     (eq? m 'rear))) (empty))
                           ((eq? m 'front) (front))
                           ((eq? m 'rear) (rear))
                           (else (error "insert-deque!: unknown method:" m))))))
    dispatch))

(define (delete-deque! dq)
  (let* ((front (lambda ()
                  (set-front-ptr! dq (next-ptr (front-ptr dq)))
                  (if (not (null? (front-ptr dq)))
                      (set-prev-ptr! (front-ptr dq) '()))
                  dq))
         (rear (lambda ()
                 (set-rear-ptr! dq (prev-ptr (rear-ptr dq)))
                 (if (not (null? (rear-ptr dq)))
                     (set-next-ptr! (rear-ptr dq) '()))
                 dq))
         (dispatch (lambda (m)
                     (cond ((empty-deque? dq) (error "delete-deque!: empty deque:" dq))
                           ((eq? m 'front) (front))
                           ((eq? m 'rear) (rear))
                           (else (error "delete-deque!: unknown method:" m))))))
    dispatch))

(define (front-insert-deque! dq item)
  ((insert-deque! dq item) 'front))

(define (rear-insert-deque! dq item)
  ((insert-deque! dq item) 'rear))

(define (front-delete-deque! dq)
  ((delete-deque! dq) 'front))

(define (rear-delete-deque! dq)
  ((delete-deque! dq) 'rear))

(define (print-deque dq)
  (letrec ((p (lambda (elem)
                (display (car elem))
                (if (not (null? (next-ptr elem)))
                    (begin (display " ")
                           (p (next-ptr elem)))))))
    (display "(")
    (if (not (empty-deque? dq))
        (p (front-ptr dq)))
    (display ")")
    (newline)))

(let ((dq (make-deque)))
  (rear-insert-deque! dq 'c)
  (print-deque dq)
  (rear-insert-deque! dq 'd)
  (print-deque dq)
  (rear-insert-deque! dq 'e)
  (print-deque dq)
  (front-insert-deque! dq 'b)
  (print-deque dq)
  (front-insert-deque! dq 'a)
  (print-deque dq)
  (rear-delete-deque! dq)
  (print-deque dq)
  (rear-delete-deque! dq)
  (print-deque dq)
  (front-delete-deque! dq)
  (print-deque dq)
  (front-delete-deque! dq)
  (print-deque dq)
  (front-delete-deque! dq)
  (print-deque dq))
;; (c)
;; (c d)
;; (c d e)
;; (b c d e)
;; (a b c d e)
;; (a b c d)
;; (a b c)
;; (b c)
;; (c)
;; ()
