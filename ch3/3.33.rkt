#lang sicp

(define (for-each-except x proc l)
  (letrec ((f (lambda (l)
                (if (not (null? l))
                    (begin (if (not (eq? (car l) x))
                               (proc (car l)))
                           (f (cdr l)))))))
    (f l)))

(define (tell-receive constraint)
  (constraint 'receive))

(define (tell-refresh constraint)
  (constraint 'refresh))

(define (make-connector)
  (let* ((value #f)
         (informant #f)
         (constraints #f)
         (has-value? (lambda ()
                       (not (eq? informant #f))))
         (set-value (lambda (n source)
                      (cond ((not (has-value?))
                             (set! value n)
                             (set! informant source)
                             (for-each-except source
                                              tell-receive
                                              constraints))
                            ((not (= value n))
                             (error "connector: set-value: contradiction:"
                                    (list value n))))))
         (forget-value (lambda (source)
                         (if (eq? source informant)
                             (begin (set! informant #f)
                                    (for-each-except source
                                                     tell-refresh
                                                     constraints)))))
         (connect (lambda (c)
                    (if (not (memq c constraints))
                        (set! constraints
                              (cons c constraints)))
                    (if (has-value?)
                        (tell-receive c))))
         (dispatch (lambda (m)
                     (case m
                       ('get-value value)
                       ('has-value? (has-value?))
                       ('set-value set-value)
                       ('forget-value forget-value)
                       ('connect connect)
                       (else (error "connector: unknown method:" m))))))
    dispatch))

(define (get-value connector)
  (connector 'get-value))

(define (has-value? connector)
  (connector 'has-value?))

(define (set-value connector n source)
  ((connector 'set-value) n source))

(define (forget-value connector source)
  ((connector 'forget-value) source))

(define (connect connector c)
  ((connector 'connect) c))

(define (adder sum x y)
  (let* ((receive (lambda ()
                    (cond ((and (has-value? x)
                                (has-value? y))
                           (set-value! sum
                                       (+ (get-value x)
                                          (get-value y))))
                          ((and (has-value? x)
                                (has-value? sum))
                           (set-value! sum
                                       (- (get-value sum)
                                          (get-value x))))
                          ((and (has-value? x)
                                (has-value? sum))
                           (set-value! sum
                                       (- (get-value sum)
                                          (get-value x)))))))
         (refresh (lambda ()
                    ()))
         (dispatch (lambda (m)
                     (case m
                       ()
                       ()
                       (else (error "adder: unknown method:" m))))))
    ()
    ()
    ()
    dispatch))

;(define (adder a1 a2 sum)
;  (letrec ((process-new-value (lambda ()
;                                (cond ((and (has-value? a1)
;                                            (has-value? a2))
;                                       (set-value! sum
;                                                   (+ (get-value a1)
;                                                      (get-value a2))
;                                                   me))
;                                      ((and (has-value? a1)
;                                            (has-value? sum))
;                                       (set-value! a2
;                                                   (- (get-value sum)
;                                                      (get-value a1))
;                                                   me))
;                                      ((and (has-value? a2)
;                                            (has-value? sum))
;                                       (set-value! a1
;                                                   (- (get-value sum)
;                                                      (get-value a2))
;                                                   me)))))
;           (process-forget-value (lambda ()
;                                   (forget-value! sum me)
;                                   (forget-value! a1 me)
;                                   (forget-value! a2 me)
;                                   (process-new-value)))
;           (me (lambda (request)
;                 (cond ((eq? request 'I-have-a-value) (process-new-value))
;                       ((eq? request 'I-lost-my-value) (process-forget-value))
;                       (else (error "adder: undefined operation:" request))))))
;    (connect a1 me)
;    (connect a2 me)
;    (connect sum me)
;    me))
;
;(define (multiplier m1 m2 product)
;  (letrec ((process-new-value (lambda ()
;                                (cond ((and (has-value? m1)
;                                            (has-value? m2))
;                                       (set-value! product
;                                                   (* (get-value m1)
;                                                      (get-value m2))
;                                                   me))
;                                      ((and (has-value? m1)
;                                            (has-value? product))
;                                       (set-value! m2
;                                                   (/ (get-value product)
;                                                      (get-value m1))
;                                                   me))
;                                      ((and (has-value? m2)
;                                            (has-value? product))
;                                       (set-value! m1
;                                                   (/ (get-value product)
;                                                      (get-value m2))
;                                                   me)))))
;           (process-forget-value (lambda ()
;                                   (forget-value! product me)
;                                   (forget-value! m1 me)
;                                   (forget-value! m2 me)
;                                   (process-new-value)))
;           (me (lambda (request)
;                 (cond ((eq? request 'I-have-a-value) (process-new-value))
;                       ((eq? request 'I-lost-my-value) (process-forget-value))
;                       (else (error "multiplier: undefined operation:" request))))))
;    (connect m1 me)
;    (connect m2 me)
;    (connect product me)
;    me))
;
;(define (constant value connector)
;  (let ((me (lambda (request)
;              (error "constant: undefined operation:" request))))
;    (connect connector me)
;    (set-value! connector value me)
;    me))
;
;(define (probe name connector)
;  (let* ((print-probe (lambda (value)
;                        (display "probe: ")
;                        (display name)
;                        (display " = ")
;                        (display value)
;                        (newline)))
;         (process-new-value (lambda ()
;                              (print-probe (get-value connector))))
;         (process-forget-value (lambda ()
;                                 (print-probe "?")))
;         (me (lambda (request)
;               (cond ((eq? request 'I-have-a-value) (process-new-value))
;                     ((eq? request 'I-lost-my-value) (process-forget-value))
;                     (else (error "" request))))))
;    (connect connector me)
;    me))
;
;(define (averager a b c)
;  (letrec ((process-new-value (lambda ()
;                                (cond ((and (has-value? a)
;                                            (has-value? b))
;                                       (set-value! c
;                                                   (/ (+ (get-value a)
;                                                         (get-value b))
;                                                      2)
;                                                   me))
;                                      ((and (has-value? a)
;                                            (has-value? c))
;                                       (set-value! b
;                                                   (- (* 2 (get-value c))
;                                                      (get-value a))
;                                                   me))
;                                      ((and (has-value? b)
;                                            (has-value? c))
;                                       (set-value! a
;                                                   (- (* 2 (get-value c))
;                                                      (get-value b))
;                                                   me)))))
;           (process-forget-value (lambda ()
;                                   (forget-value! c me)
;                                   (forget-value! a me)
;                                   (forget-value! b me)
;                                   (process-new-value)))
;           (me (lambda (request)
;                 (cond ((eq? request 'I-have-a-value) (process-new-value))
;                       ((eq? request 'I-lost-my-value) (process-forget-value))
;                       (else (error "averager: undefined operation:" request))))))
;    (connect a me)
;    (connect b me)
;    (connect c me)
;    me))
